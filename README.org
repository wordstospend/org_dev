This is the lexer/parser project for org mode

Org mode does not seem to be as unabiguous as we might like but that is fine.
This is just a first bite at the apple
* DONE Make it work
** Code complete
*** DONE Parser org.y
This seems to be mostly done I'm sure I've got some gaps but for now this
looks like it is good enough
*** DONE parser V2 change order of docuement so it is top to bottom traversal
*** DONE Lexer org.l
This has a bunch of code but really needs to be from scratch. The current
plan is add stubs for all of the tokens that will need to be output by the
lexer and then to go one by one and add work for them. At each case we
should add a test case for that token
** Testing sweet
*** DONE Testing Harness
We now can pass in a filename to the resulting org-parser but we still need
to add a bit more machinery, maybe a prove script or some such thing
*** DONE Testing Harness for AST result
**** DONE output ast to file
the basis for this work is /Users/nfair/Documents/personal_dev/LexAndYaccCode/calc3.y
***** DONE define a set of nodes for the ast
The question is for things such as 'priority' where it may or may not exist
Should I create a struct to store the node then detect the nature of the struct
in the parent rule action (in this case headline). Or can just do no action
and if so can I detect the lack of value in the parent action
****** DONE todoNode
****** DONE priorityNode
****** DONE titleNode
****** DONE tagsNode
****** DONE headlineNode
***** DONE define functions that return them
***** DONE define parser actions to call node creation funcitons
***** DONE define a fuction that reads the ast and outputs it as an in-order traversal
**** DONE compaire ast from file parser output
*** DONE Unit test
* TODO Make it work better
** TODO priority
** TODO define a section
** TODO add special word "COMMENT" to headline
** TODO add spical tag "ARCHIVE"
** TODO add Greater Element
* Objective C realease
** TODO research and outline

* org parser notes
a headline is a child of the current parent if its star count > the cout of
the parent.

otherwise the current parent is set to the parent of the current parent and
the rule is applied again.

how do I know if I am seperated from  the next thing?

 a priority, tags, and todo must be sandwhiched by \s or \n or end of file
 we can't detect end of file with anything else but it will by length nice ok
I got this

How do I deal with the title? Maybe what I do is have words and white space.
* Org structure notes from org-element.el
Greater Elements/Elements/Objects can be thought of as a node of the type
(TYPE, PROPERTY, CONTENTS)
Universal properties
- :begin
- :end ::  the beginning and ending buffer positions of the considered element or object
- :post-blank ::  which holds the number of blank lines, or white spaces at its end
- :parent
** TODO Greater Elements [0/9]
- [ ] blocks :: #+BEGIN_NAME ... #+END_NAME
  - [ ] `center-block'
  - [ ] `dynamic-block' ::#+BEGIN: block_name :paramkey1 param1 ...
  - [ ] `quote-block'
  - [ ] `special-block' :: has many names which are used by differnt exporter backends
- [ ] `drawer' :: ^[\t ]*\:(PROPERTIES|CLOCK|LOGBOOK|RESULT):[\t ]*$ some lines later ^[\t ]*:END:[\t ]*$
- [ ] `footnote-definition'
- [ ] `headline'
- [ ] `inlinetask'
- [ ] `item'
- [ ] `plain-list'
- [ ] `property-drawer'
- [ ] `section'
** TODO Elements [0/19]
- [ ] `comment-block'
- [ ] `example-block'
- [ ] `export-block'
- [ ] `src-block'
- [ ] `verse-block'
- [ ] `babel-call'
- [ ] `clock'
- [ ] `comment'
- [ ] `diary-sexp'
- [ ] `fixed-width'
- [ ] `horizontal-rule'
- [ ] `keyword'
- [ ] `latex-environment'
- [ ] `node-property'
- [ ] `paragraph'
- [ ] `planning'
- [ ] `quote-section'
- [ ] `table'
- [ ] `table-row'
Among them,`paragraph' and `verse-block' types can contain Org objects and plain text.
** Objects
;; Objects are related to document's contents. Some of them are
;; recursive. Associated types are of the following: `bold', `code',
;; `entity', `export-snippet', `footnote-reference',
;; `inline-babel-call', `inline-src-block', `italic',
;; `latex-fragment', `line-break', `link', `macro', `radio-target',
;; `statistics-cookie', `strike-through', `subscript', `superscript',
;; `table-cell', `target', `timestamp', `underline' and `verbatim'.
;;
;; Some elements also have special properties whose value can hold
;; objects themselves (i.e. an item tag or a headline name). Such
;; values are called "secondary strings". Any object belongs to
;; either an element or a secondary string.
* Work in progress
In looking at drawers I realize that I need to have sublexer for sections.
That way drawers can be found more easily sense it can be said they exist only
in a section. The other option is to remove the concept of a section from the lexer
It doesn't seem to be a lexical idea, but instead a parse node generated by the union
of its children. I believe that seems to be the better direction to go.
If I define drawers, paragraphs, and list as types then I will have most of the
functionality I want.
